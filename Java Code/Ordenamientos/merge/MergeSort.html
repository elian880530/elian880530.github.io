<HTML>
<HEAD>
<meta http-equiv=Content-Type content="text/html;  charset=iso-8859-1">
<TITLE>MergeSort</TITLE>
</HEAD>
<BODY bgcolor="#000000">
<!-- URL's used in the movie-->
<!-- text used in the movie-->
<!--MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendente<P ALIGN="RIGHT"><FONT FACE="Comic Sans MS" SIZE="16" COLOR="#FFFF00">a</FONT></P><P ALIGN="RIGHT"><FONT FACE="Comic Sans MS" SIZE="13" COLOR="#FFFF00">tmpArray</FONT></P>VERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL MergeSortAlgoritmos de Ordenación - Departamento de Ing. TelemáticaUniversidad Carlos III Madridpublic static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];public static void mergeSort(int a[ ], int tmpArray[],int left, int right ){    if( left < right ){        int center = ( left + right ) / 2;        mergeSort( a, tmpArray, left, center );        mergeSort( a, tmpArray, center+1, right );        merge( a, tmpArray, left, center+1, right );    }private static void merge( int a[ ],int tmpArray[],int leftPos, int rightPos, int rightEnd){        int leftEnd = rightPos - 1;        int tmpPos = leftPos;        int numElements = rightEnd - leftPos + 1;        while( leftPos<=leftEnd && rightPos<=rightEnd ){            if( a[ leftPos ]<( a[ rightPos ] ) )                tmpArray[ tmpPos++ ] = a[ leftPos++ ];            else                tmpArray[ tmpPos++ ] = a[ rightPos++ ];        }        while( leftPos <= leftEnd )            while( rightPos <= rightEnd )         for( int i=0; i < numElements; i++, rightEnd-- )            a[ rightEnd ] = tmpArray[ rightEnd ];AleatoriosCancelarSiguientePlayAscendenteDescendenteVERSIONFINAL VERSIONFINAL --><OBJECT classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
 codebase="swflash.cab#version=6,0,0,0" tppabs="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
 WIDTH="100%" HEIGHT="100%" id="MergeSort" ALIGN="">
 <PARAM NAME=movie VALUE="MergeSort.swf" tppabs="http://www.it.uc3m.es/java/ordenacion/MergeSort.swf"> <PARAM NAME=menu VALUE=false> <PARAM NAME=quality VALUE=high> <PARAM NAME=bgcolor VALUE=#000000> <EMBED src="MergeSort.swf" tppabs="http://www.it.uc3m.es/java/ordenacion/MergeSort.swf" menu=false quality=high bgcolor=#000000  WIDTH="100%" HEIGHT="100%" NAME="MergeSort" ALIGN=""
 TYPE="application/x-shockwave-flash" PLUGINSPAGE="http://www.macromedia.com/go/getflashplayer"></EMBED>
</OBJECT>
</BODY>
</HTML>
